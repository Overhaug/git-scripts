#!/bin/zsh

LBLUE="\033[1;34m"
LRED="\033[1;31m"
YELLOW="\033[1;33m"
NC="\033[0m"

args=("$@")
gitAuthor="$(eval "git config --global --get user.name")"

validateDate() {
  IFS=\= read -r left right <<<"$1"
  if [[ $right =~ ^[0-9]{4}-[0-9]{2}-[0-9]{2}$ ]]; then
    validDate=$1
    return 0
  else
    echo "Date $right is in an invalid format (not YYYY-MM-DD)"
    return 1
  fi
}

splitAndValidateArgOnEq() {
  IFS=\= read -r left right <<<"$1"
  if [[ $right != "" ]] && [[ $left != "" ]]; then
    return 0
  else
    return 1
  fi
}

insertSeparator() {
  printf "\n$NC"
  printf %"$COLUMNS"s | tr " " "-"
}

printRepoPath() {
  printf "$LBLUE"
  printf "$pure\n$NC"
}

if [[ ${args[1]} == "status" ]]; then
  gitCommand="status"
  type="status"
elif [[ ${args[1]} == "log" ]]; then
  gitCommand="log --graph --pretty=format:""'%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)<%an>%Creset' --abbrev-commit"
  type="log"
  unrecognizedArgs=()
  for arg in ${args}; do
    if [[ $arg == "--until"* ]] || [[ $arg == "--since"* ]]; then
      if validateDate "$arg"; then
        gitCommand="$gitCommand $validDate"
      else
        exit
      fi
    elif [[ $arg == "--author"* ]]; then
      splitAndValidateArgOnEq "$arg"
      gitCommand="$gitCommand --author='$right'"
    elif [[ $arg == "self" ]]; then
      filterByAuthor="true"
      gitCommand="$gitCommand --author='$gitAuthor'"
    elif [[ $arg == "--max"* ]]; then
      splitAndValidateArgOnEq "$arg"
      gitCommand="$gitCommand -n$right"
    elif [[ $arg != "$type" ]]; then
      unrecognizedArgs+=("$arg")
    fi
  done
elif [[ ${args[1]} == "cmd" ]]; then
  type="cmd"
  echo -n "Command: git "
  read answer
  gitCommand=$answer
  cmdType=$answer

  echo -n "Sure? (y/n) "
  read answer2
  if [[ $answer2 == "n" ]]; then
    exit
  fi
else
  echo "You must specify a command"
  exit
fi

if [[ $type == "cmd" ]]; then
  printf "$YELLOW> Executing git command '$cmdType' over repositores in $PWD ...$NC \n"
else
  printf "$YELLOW> Executing git command '$type' over repositores in $PWD ...$NC \n"
fi

root=$PWD
repos=0
numReposMatched=0
numCommits=0
numCommitsByAuthor=0
find . -type d \( -path "*/node_modules/*" -o -path "*/.idea/*" -o -path "*/.vscode/*" \) -prune -false -o -name '*.git' | while read -r dir; do
  # sanity check
  if [[ $dir == *"/.git" ]]; then
    ((repos++))
    # todo combine replaces
    pure="${dir//\/.git/}"
    pure="${pure//./}"

    # Run command in repo
    eval "cd $root/$pure"
    gst="$(eval "git $gitCommand")"
    if [[ $type == "status" ]]; then
      if [[ $gst == *"Your branch is ahead"* ]]; then # todo a faster way of matching?
        ((numReposMatched++))
        printRepoPath
        printf "$gst" | sed -n 1,2p
        insertSeparator
      fi
    elif [[ $type == "log" ]] && [[ $gst == *" "* ]]; then
      printRepoPath
      ((numReposMatched++))
      printf "$gst"

      while read -r line; do
        if [[ $filterByAuthor == "true" ]]; then
          ((numCommitsByAuthor++))
          ((numCommits++))
        else
          ((numCommits++))
        fi
      done <<<"$gst"

      insertSeparator
    elif [[ $type == "cmd" ]]; then
      if [[ $gst == *" "* ]]; then
        printRepoPath
        ((numReposMatched++))
        printf "$gst"
        insertSeparator
      fi
    fi
  fi
done

if [[ $type == "status" ]]; then
  echo "${YELLOW}> Checked $repos repositories, $numReposMatched are ahead"
elif [[ $type == "log" ]]; then
  if [[ $filterByAuthor == "true" ]]; then
    echo "${YELLOW}> Checked $repos repositories, of which $numReposMatched contained $numCommits commits, $numCommitsByAuthor by you, within the given date range"
  else
    echo "${YELLOW}> Checked $repos repositories, of which $numReposMatched contained a total of $numCommits commits within the given date range"
  fi
fi

if ((${#unrecognizedArgs[@]} != 0)); then
  echo "Ignored arguments: $unrecognizedArgs"
fi
